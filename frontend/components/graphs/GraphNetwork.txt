<script>
  import * as d3 from 'd3';

  export default {
    name: 'GraphNetwork',
    props: ['data'],
    watch: {
      data: function (newData) {
        // console.log(this.preprocess(newData));
        // this.graph(this.preprocess(newData));
        this.chart(this.preprocess(newData));
        // this.testD3(newData);
      }
    },
    methods: {
      chart (data) {

        // const data = sample;

        // const [width, height] = [1000, 1000];
        const [width, height] = [window.innerWidth - 280, window.innerHeight - 38];

        // const links = data.links.map(d => Object.create(d));
        // const nodes = data.nodes.map(d => Object.create(d));
        const links = data.links;
        const nodes = data.nodes;

        const radius = 10;

        const simulation = d3.forceSimulation(nodes)
          .force("link",
            d3.forceLink(links).id(d => d.name)
            .strength(0.1)
            // .distance(200)
          )
          .force("charge",
            d3.forceManyBody()
            .strength(-20)
          )
          .force("center",
            d3.forceCenter(width/2, height/2)
          );
          // .force("collision", d3.forceCollide(15));

        const dragstarted = (event, d) => {
          if (!event.active) simulation.alphaTarget(0.3).restart();
          d.fx = d.x;
          d.fy = d.y;
        };
        const dragged = (event, d) => {
          d.fx = event.x;
          d.fy = event.y;
        };
        const dragended = (event, d) => {
          if (!event.active) simulation.alphaTarget(0);
          d.fx = null;
          d.fy = null;
        };

        const linkedByIndex = [];
        links.forEach(d => {
          linkedByIndex.push(`(${d.source.index}, ${d.target.index})`);
        });
        const isConnected = (a, b) => {
          return linkedByIndex.includes(`(${a.index}, ${b.index})`) || linkedByIndex.includes(`(${b.index}, ${a.index})`) || a.index === b.index;
        };

        const drawChart = () => {
          const svg = d3.select("svg")
            .attr("viewBox", [0, 0, width, height])
            // .call(d3.scroll((x, scale) => console.log([x, scale])))

          const link = svg.append("g")
            .attr("stroke", "#aaa")
            .attr("stroke-opacity", 0.2)
            .selectAll("line")
            .data(links)
            .join("line")
              .attr("stroke-width", d => Math.sqrt(d.value) / 2);
          const node = svg.append("g")
            // .attr("stroke", "#000")
            .attr("class", "nodes")
            .selectAll("circle")
            .data(nodes)
            .join("circle")
              .attr("r", radius)
              // .attr("fill", d => color(d))
              .attr("fill", "black")
              .attr("opacity", 0.2)
              // .call(drag(simulation));
              // .call(drag(simulation))
              .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended)
              )
              .on("mouseover", d => MouseOver(d))
              .on("mouseout", d => MouseOut(d))
              .on("click", d => Click(d));

          const textElems = svg.append('g')
            .attr('class', "textElems")
            .selectAll('text')
            .data(nodes)
            .join('text')
              .text(d => d.name)
              .attr('font-size',10)
              .attr('font-size',10);

          simulation.on("tick", () => {
            link
              .attr("x1", d => d.source.x)
              .attr("y1", d => d.source.y)
              .attr("x2", d => d.target.x)
              .attr("y2", d => d.target.y);
            node
              .attr("cx", function(d) { return d.x = Math.max((radius+1), Math.min(width - (radius+1), d.x)); })
              .attr("cy", function(d) { return d.y = Math.max((radius+1), Math.min(height - (radius+1), d.y)); });
            textElems
              .attr("x", d => d.x + 10)
              .attr("y", d => d.y)
              .attr("visibility", "hidden");
          });


          const Focus = (d) => {
            node.style('opacity', o => {
              return (isConnected(d, o) ? 1 : 0.2);
            });
            link.style('stroke-opacity', o => {
              return (o.source === d || o.target === d ? 1 : 0.2);
            });
            textElems.style('visibility', o => {
              return (isConnected(d, o) ? "visible" : "hidden");
            });
          }

          const MouseOver = (d_all) => {
            const d = d_all.target.__data__;
            Focus(d);
            // const phils = eval(context.phils);
            // const ph_found = phils.find(ph => ph.name == d.name);
            // context.Over.setOveredPh(ph_found);
          };
          const MouseOut = (d_all) => {
            // const d = d_all.toElement.__data__;
            node.style("opacity", 0.2);
            link.style('stroke-opacity', 0.2);
            textElems.style('visibility', 'hidden');
            context.Over.setOveredPh(null);
          };
          const Click = (d_all) => {
            const d = d_all.target.__data__;
            Focus(d);
            d3.select(this)
              .attr("id", "select");
            // const phils = eval(context.phils);
            // const ph_found = phils.find(ph => ph.name == d.name);
            // context.Click.setClickedPh(ph_found);
          };
        }

        drawChart();

      },
      testD3 (data) {
        data.forEach(d=>{
          d.count = +d.count.split(",").join("")
        });
        console.log('test d3');
        const svg = d3.select("svg")
        console.log('svg', svg);
        svg.attr("width",960).attr("height",540)

        var scaleHeight = d3.scaleLinear()
              .domain([0,4000000])
              .range([0,400])
        var scaleColor = d3.scaleLinear()
              .domain([0,4000000])
              .range(['blue','#fc993c'])
        var groups = svg.selectAll("g.city")
          .data(data)
          .enter()
          .append("g")
        groups.append('text')
              .text(d=>d.city)
              .attr("y",520)
              .attr("x",(d,i)=>i*100)
        groups.append("circle")
              .attr("cx",(d,i)=>i*100+20)
              .attr("cy",400)
              .attr("r",(d)=>0)
              .attr("fill",(d)=>scaleColor(d.count))
              .transition()
              .duration(1000)
              .delay((d,i)=>i*200)
              .attr("r",(d)=>scaleHeight(d.count)/10)
              .attr("cy",200)

        groups.append("text")
              .text(d=>d.count)
              .attr("x",(d,i)=>i*100+10)
              .attr("y", (d)=>480-scaleHeight(d.count))
              .style('font-size',"13px")
              .style("opacity",0)
        .transition()
              .duration(1000) 
              .delay((d,i)=>i*200)
              .style("opacity",1)
              
        var line = d3.line()
                    .x((d,i)=>i*100)
                    .y((d,i)=>-d.count/10000+500)
        svg.append("path")
          .datum(data)
          .attr("d",line)
          .attr("fill","none")
          .attr("stroke","black") 
      },
      preprocess (data) {
        const nodes = data.map(d => {
          return {"name": d.name}
        });
        const links = data.map(d => {
          if (d.influences) {
            return d.influences.map(i => {
              return {
                "source": data.find(dd => dd.id === i).name,
                "target": d.name
              }
            })
          }
        });
        return {
          "nodes": nodes,
          "links": links
        };
      },
      graph (data) {
        const [width, height] = [500, 500];
        // const [width, height] = [window.innerWidth - 280, window.innerHeight - 38];

        const links = data.links;
        const nodes = data.nodes;
        // const links = data.links.map(d => Object.create(d));
        // const nodes = data.nodes.map(d => Object.create(d));

        const radius = 10;

        const svg = d3.select("svg")
          .attr("viewBox", [0, 0, width, height]);

        const simulation = d3.forceSimulation(nodes)
          .force("link",
            d3.forceLink(links)
              .id(d => d.name)
              .strength(0.1)
            // .distance(200)
          )
          .force("charge",
            d3.forceManyBody()
              .strength(-20)
          )
          .force("center",
            d3.forceCenter(width/2, height/2)
          );
          // .force("collision", d3.forceCollide(15));


        const drawGraph = (data) => {
          // force
          //   .nodes(nodes)
          //   .links(links)
          //   .start();
          simulation.start();

          const link = svg.append("g")
            .attr("stroke", "#aaa")
            .attr("stroke-opacity", 0.2)
            .selectAll("line")
            .data(links)
            .join("line")
              // .attr("stroke-width", d => Math.sqrt(d.value) / 2);
          const node = svg.append("g")
            .attr("class", "nodes")
            .selectAll("circle")
            .data(nodes)
            .join("circle")
              .attr("r", radius)
              .attr("fill", "black")
              .attr("opacity", 0.2)
              .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended)
              )
              .on("mouseover", d => eventMouseOver(d))
              .on("mouseout", d => eventMouseOut(d))
              .on("click", d => eventClick(d));

          const textElems = svg.append('g')
            .attr('class', "textElems")
            .selectAll('text')
            .data(nodes)
            .join('text')
              .text(d => d.name)
              .attr('font-size',10)
              .attr('font-size',10);

          simulation()
            // .nodes(nodes)
            .on("tick", () => {
              link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);
              node
                .attr("cx", function(d) { return d.x = Math.max((radius+1), Math.min(width - (radius+1), d.x)); })
                .attr("cy", function(d) { return d.y = Math.max((radius+1), Math.min(height - (radius+1), d.y)); });
              textElems
                .attr("x", d => d.x + 10)
                .attr("y", d => d.y)
                .attr("visibility", "hidden");
            });
        }


        const dragstarted = (event, d) => {
          if (!event.active) simulation.alphaTarget(0.3).restart();
          d.fx = d.x;
          d.fy = d.y;
        };
        const dragged = (event, d) => {
          d.fx = event.x;
          d.fy = event.y;
        };
        const dragended = (event, d) => {
          if (!event.active) simulation.alphaTarget(0);
          d.fx = null;
          d.fy = null;
        };

        const funcFocus = (d) => {
          const isConnected = (a, b) => {
            const linkedByIndex = links.map(d => {
              return `(${d.source.index}, ${d.target.index})`;
            });
            return linkedByIndex.includes(`(${a.index}, ${b.index})`) || linkedByIndex.includes(`(${b.index}, ${a.index})`) || a.index === b.index;
          };
          node.style('opacity', o => isConnected(d, o) ? 1 : 0.2);
          link.style('stroke-opacity', o => o.source === d || o.target === d ? 1 : 0.2);
          textElems.style('visibility', o => isConnected(d, o) ? "visible" : "hidden");
        };

        const eventMouseOver = (d_all) => {
          const d = d_all.target.__data__;
          funcFocus(d);
          // const phils = eval(context.phils);
          const ph_found = phils.find(ph => ph.name == d.name);
          // context.Over.setOveredPh(ph_found);
        };
        const eventMouseOut = (d_all) => {
          // const d = d_all.toElement.__data__;
          node.style("opacity", 0.2);
          link.style('stroke-opacity', 0.2);
          textElems.style('visibility', 'hidden');
          // context.Over.setOveredPh(null);
        };
        const eventClick = (d_all) => {
          const d = d_all.target.__data__;
          funcFocus(d);
          d3.select(this)
            .attr("id", "select");
          // const phils = eval(context.phils);
          const ph_found = phils.find(ph => ph.name == d.name);
          // context.Click.setClickedPh(ph_found);
        };

        //// const setOveredPh = context.Over.setOveredPh;
        //// const setClickedPh = context.Click.setClickedPh;
      }
    }
  }
</script>

<template>
  <div class="container">
    <svg></svg>
  </div>
</template>

<style>
  svg {
    border: 5px solid #000;
    background-color: white;
  }
  .chartNetwork {
    position: inherit;
    width: 100%;
    height: 100%;
    margin: 0;
    /* overflow-x: scroll; */
    z-index: 1;
    /* overflow-y: hidden; */
    /* background-color: green; */
    /* border: 1px solid black; */
  }
  .chartNetwork svg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }
  /* .chartNetwork svg text {
    font-size: 10px;
  } */
  .textElems {
    font-family: "Courier";
    font-size: 10;
  }
  .connect {
    color: "red";
  }
</style>